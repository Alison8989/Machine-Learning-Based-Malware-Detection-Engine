# -*- coding: utf-8 -*-

from __future__ import division
from peframe.peframe import pef_class
import json
import time

high_freq_api = [
        "accept",
		"AddCredentials",
		"bind",
        'CopyFile',
        'CreateFile',
		"CertDeleteCertificateFromStore",
		"CheckRemoteDebuggerPresent",
        'CheckSumMappedFile',
		"CloseHandle",
		"connect",
		"ConnectNamedPipe",
		"CreateMutex",
		"CreateProcess",
		"CreateToolhelp32Snapshot",
		"CreateFileMapping",
		"CreateRemoteThread",
		"CreateDirectory",
		"CreateService",
		"CreateThread",
		"CryptEncrypt",
        "CryptDecrypt",
        "DeleteDirectory",
        'DeleteFile',
		"DeleteCriticalSection",
		"DeviceIoControl",
        'DisableThreadLibraryCalls',
		"DisconnectNamedPipe",
		"DNSQuery",
		"EnumProcesses",
		"ExitProcess",
		"ExitThread",
		"FindWindow",
		"FindResource",
		"FindFirstFile",
		"FindNextFile",
		"FltRegisterFilter",
		"FtpGetFile",
		"FtpOpenFile",
        'GetAsyncKeyState',
		"GetCommandLine",
		"GetComputerName",
		"GetCurrentProcess",
		"GetThreadContext",
		"GetDriveType",
		"GetFileSize",
		"GetFileAttributes",
		"GetHostByAddr",
		"GetHostByName",
		"GetHostName",
        "GetLastError",
		"GetModuleHandle",
		"GetModuleFileName",
		"GetProcAddress",
		"GetStartupInfo",
		"GetSystemDirectory",
        'GetSystemTime',
		"GetTempFileName",
		"GetTempPath",
		"GetTickCount",
		"GetUpdateRect",
		"GetUpdateRgn",
		"GetUserNameA",
		"GetUrlCacheEntryInfo",
		"GetVersionEx",
		"GetWindowsDirectory",
		"GetWindowThreadProcessId",
		"HeapAlloc",
		"HttpSendRequest",
		"HttpQueryInfo",
        '_initterm',
		"IsBadReadPtr",
		"IsBadWritePtr",
		"IsDebuggerPresent",
		"InitializeCriticalSection",
		"InternetCloseHandle",
		"InternetConnect",
		"InternetCrackUrl",
		"InternetQueryDataAvailable",
		"InternetGetConnectedState",
		"InternetOpen",
		"InternetQueryDataAvailable",
		"InternetQueryOption",
		"InternetReadFile",
		"InternetWriteFile",
		"LdrLoadDll",
		"LoadLibrary",
		"LockResource",
		"listen",
		"lstrcmp",
        'MapFileAndCheckSum',
		"MapViewOfFile",
        'MAPISendMail'
        'MAPIReadMail'
		"MessageBox",
		"OutputDebugString",
		"OpenFileMapping",
		"OpenMutex",
		"OpenProcess",
        'OpenService',
		"Process32First",
		"Process32Next",
		"recv",
		"ReadFile",
		"ReadProcessMemory",
		"RegCloseKey",
		"RegCreateKey",
		"RegDeleteKey",
		"RegDeleteValue",
		"RegEnumKey",
		"RegOpenKey",
		"ReleaseMutex",
		"RemoveDirectory",
        'RtlAdjustPrivilege',
        "RtlCompressBuffer",
        'RtlDecompressBuffer',
		"send",
        "SetEnvironmentVariable",
        "SetFileAttributes",
		"SetFilePointer",
		"SetKeyboardState",
		"SetWindowsHook",
		"ShellExecute",
		"Sleep",
		"socket",
		"StartService",
		"TerminateProcess",
		"UnhandledExceptionFilter",
		"URLDownload",
		"VirtualAlloc",
		"VirtualFree",
		"VirtualProtect",
		"WaitForSingleObject",
		"WriteProcessMemory",
		"WriteFile",
		"WSASend",
		"WSASocket",
		"WSAStartup",
        'WinExec',
		"ZwQueryInformation"
]
mal_string=['Scripting.FileSystemObject','Wscript.shell']

high_freq_resource = [11, 14, 16]

dllmode = [0x0040, 0x0080, 0x0100, 0x0200, 0x0400, 0x0800, 0x8000]
tchamode = [0x00000020, 0x00000040, 0x00000080, 0x02000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000]

norm_section_name=['.text',	'.bss',	'.rdata','.data','.rsrc','.edata','.idata','.pdata',
'.debug',	'.DATA','.CODE','.BSS',	'.sxdata','.itext',	'.adata','.ndata','.re',
'loc',	'._winzip_','.tls','UPX1',	'.UPX0',	'.boom',	'.seau',	'.code',	'.Shared',	'.gentee',
'.asp',	'.CRT','.PAGE',	'INIT','.tsu.']

class feat_class():
    def __init__(self,totalFeat):
        self.totalfeat = totalFeat
        self.feature = [0 for i in range(self.totalfeat)]
        self.index = 0
    def app(self,feat):
        if self.index < self.totalfeat:
            self.feature[self.index] = feat
            self.index += 1
        else:
            raise "Value Error:out of length"
    def ext(self,feat):
        templen = len(feat)
        if (self.index + templen -1) < self.totalfeat:
            for i in range(templen):
                self.feature[self.index + i] = feat[i]
            self.index += templen
        else:
            raise "Value Error:out of length"

    def get_len(self):
        for i in range(self.index,self.totalfeat):
            if self.feature[i] != 0:
                return 0
        return self.index

    def get_feat(self):
        if self.index != self.totalfeat:
            print 'warning:some items is lacked in features'
        return self.feature


def psectname_trans(sectionName):
    if not isinstance(sectionName, str):
        sname = sectionName.decode().split('\0')[0]
    else:
        sname = sectionName.split('\0')[0]
    return sname

def is_probably_packed(pe):

    text_en = 0
    rscrc_en = 0
    total_pe_data_length = len(pe.trim())
    has_significant_amount_of_compressed_data = False

    # If some of the sections have high entropy and they make for more than 20% of the file's size
    # it's assumed that it could be an installer or a packed file
    gn = True
    tn = True
    total_compressed_data = 0
    for section in pe.sections:
        s_entropy = section.get_entropy()
        s_length = len(section.get_data())
        # The value of 7.4 is empircal, based of looking at a few files packed
        # by different packers
        if s_entropy > 7.4:
            total_compressed_data += s_length

        sname = psectname_trans(section.Name)
        if gn and ('.text' == sname or 'CODE' == sname):
            text_en = s_entropy
            gn = False
        if tn and '.rsrc' == sname :
            rscrc_en = s_entropy
            tn = False

    if total_pe_data_length == 0:
        return [False,0,0]

    if ((1.0 * total_compressed_data) / total_pe_data_length) > .2:
        has_significant_amount_of_compressed_data = True

    return [has_significant_amount_of_compressed_data,text_en,rscrc_en]


def feature_get(pfiles,filename):
    #feature = feat_class()

    feature,bfea = feature_from_Peframe(filename)
    #DOS Header0
    if(hasattr(pfiles,'DOS_HEADER')):                          #1 e_lfanew:224
        feature.append(pfiles.DOS_HEADER.e_lfanew)
    else:
        feature.append(0)
    #PE HEADER
    feature.append(pfiles.FILE_HEADER.NumberOfSections)        #2 numberofSections
    feature.append(pfiles.FILE_HEADER.NumberOfSymbols)         #3 numberofSymbols

    #OPTIONAL HEADERD
    if (hasattr(pfiles, 'OPTIONAL_HEADER')):
        if(pfiles.OPTIONAL_HEADER.CheckSum == 0):              #4 checkSum
            feature.append(1)
        else:
            feature.append(0)

        if (pfiles.OPTIONAL_HEADER.AddressOfEntryPoint > pfiles.sections[-1].VirtualAddress):  #5 entrypoint in the last section
            feature.append(1)
        else:
            feature.append(0)

        if (pfiles.OPTIONAL_HEADER.AddressOfEntryPoint > pfiles.sections[0].VirtualAddress and \
              pfiles.OPTIONAL_HEADER.AddressOfEntryPoint < (pfiles.sections[0].VirtualAddress +pfiles.sections[0].SizeOfRawData)):
            feature.append(1)
        else:
            feature.append(0)                                      #6 entrypoint in the first section

        if (pfiles.OPTIONAL_HEADER.AddressOfEntryPoint < pfiles.sections[0].VirtualAddress or \
              pfiles.OPTIONAL_HEADER.AddressOfEntryPoint > (pfiles.sections[-1].VirtualAddress +pfiles.sections[-1].SizeOfRawData)):
            feature.append(1)
        else:
            feature.append(0)                               #7 entrypoint out of section

        for mode in dllmode:
            feature.append(mode & pfiles.OPTIONAL_HEADER.DllCharacteristics)     #8~14 dll DllCharacteristics

        feature.append(pfiles.OPTIONAL_HEADER.SizeOfCode/pfiles.OPTIONAL_HEADER.SizeOfImage)  #15 sizeofcode

        feature.append(pfiles.OPTIONAL_HEADER.SizeOfHeapCommit)                            #16 sizeofheapcommit
        feature.append( pfiles.OPTIONAL_HEADER.SizeOfHeapReserve)                           #17 sizeofheapreserve

        feature.append( pfiles.OPTIONAL_HEADER.SizeOfStackCommit)                           #18 sizeofstackcommit
        feature.append(pfiles.OPTIONAL_HEADER.SizeOfStackReserve)                           #19 sizeofstackcommit

        feature.append(pfiles.OPTIONAL_HEADER.SizeOfInitializedData/pfiles.OPTIONAL_HEADER.SizeOfImage)  #20 SizeOfInitializedData
        feature.append(pfiles.OPTIONAL_HEADER.SizeOfUninitializedData/pfiles.OPTIONAL_HEADER.SizeOfImage)   #21 SizeOfUninitializedData

        feature.append(pfiles.OPTIONAL_HEADER.MajorImageVersion)     #22 ~ 29 version information
        feature.append(pfiles.OPTIONAL_HEADER.MinorImageVersion)

        feature.append(pfiles.OPTIONAL_HEADER.MajorOperatingSystemVersion)
        feature.append(pfiles.OPTIONAL_HEADER.MinorOperatingSystemVersion)

        feature.append(pfiles.OPTIONAL_HEADER.MajorLinkerVersion)
        feature.append(pfiles.OPTIONAL_HEADER.MinorLinkerVersion)

        feature.append(pfiles.OPTIONAL_HEADER.MajorSubsystemVersion)
        feature.append(pfiles.OPTIONAL_HEADER.MinorSubsystemVersion)

        if pfiles.OPTIONAL_HEADER.ImageBase <= 0x400000:                             #30 imageBase
            feature.append(1)
        else:
            feature.append(0)

        if pfiles.OPTIONAL_HEADER.NumberOfRvaAndSizes > 0x10:                        #31 NumberOfRvaAndSizes
            feature.append(1)
        else:
            feature.append(0)

        #data directory                                                                # 32 ~ 47
        tblens = len(feature)
        m = 0
        feature.extend([0 for i in range(16)])
        for dataDirect in pfiles.OPTIONAL_HEADER.DATA_DIRECTORY:
            feature[m + tblens] = dataDirect.Size
            m += 1

        feature.append( pfiles.OPTIONAL_HEADER.DATA_DIRECTORY[2].Size / pfiles.OPTIONAL_HEADER.SizeOfImage) #48 resource table size
        #feature.append(pfiles.OPTIONAL_HEADER.DATA_DIRECTORY[1].VirtualAddress) #IATRVA

    else:
        feature.extend([0 for i in range(45)])    #45 为OPTIONAL_HEADER的特征数

    # resource detail
    tlens = len(feature)
    if tlens != 68:
        a = 0
    feature.extend([0 for i in range(len(high_freq_resource))])    #49 ~51 key resource
    resid = []
    if (hasattr(pfiles, 'DIRECTORY_ENTRY_RESOURCE')):
        for rcsc in pfiles.DIRECTORY_ENTRY_RESOURCE.entries:
            temp_res_id = rcsc.id
            if (temp_res_id is None):
                temp_res_id = rcsc.struct.Id
            m = 0
            for gres_id in high_freq_resource:
                if(gres_id == temp_res_id):
                    feature[tlens + m] = 1
                m += 1
            resid.append(temp_res_id)
    NumsOfSource_mark = [2,3,6,9,10,11,21,23,24]
    tlens = len(feature)
    if tlens != 71:
        a= 0
    feature.extend([0 for i in range(len(NumsOfSource_mark))])                #52~60  the number of key resource
    m = 0
    for i in NumsOfSource_mark:  # 统计关键资源个数
        if (i + 1) in resid:
            for rcsc in pfiles.DIRECTORY_ENTRY_RESOURCE.entries:
                temp_res_id = rcsc.id
                if (temp_res_id is None):
                    temp_res_id = rcsc.struct.Id
                if ((i + 1) == temp_res_id):
                    if (hasattr(rcsc, 'directory')):
                        feature[tlens + m]=len(rcsc.directory.entries)
                    else:
                        feature[tlens + m] = 0
                    break
        else:
            pass
        m += 1

    gbfea = [0,0,0]
    IPfunc_imports = (b'WSASocket',b'socket',b'InternetConnect')
    # dll & api MODULE
    tlens = len(feature)
    if tlens != 80:
        a= 0
    feature.extend([0 for i in range(len(high_freq_api) + 6)])             #61 ~ 63 key DLL
    api_len = 0
    Excute = False

    # 可疑行为
    suspicious_imports = set([b'LoadLibrary', b'GetProcAddress'])  # 运行导入函数,增强特征的表现力
    suspicious_imports_count = 0

    if (hasattr(pfiles, 'DIRECTORY_ENTRY_IMPORT')):
        for importeddll in pfiles.DIRECTORY_ENTRY_IMPORT:
            if (b'mscoree.dll' == importeddll.dll):
                feature[tlens] = 1
            elif (b'wsock32.dll' == importeddll.dll):
                feature[tlens+1] = 1
            elif (b'imm32.dll' == importeddll.dll):
                feature[tlens+2] = 1
            for importedapi in importeddll.imports:                #64 ~ 200 API
                api_len += 1
                if (importedapi.name is not None):
                    m = 0
                    funcName = importedapi.name.decode()

                    if not Excute :
                        if ('ShellExecute' in funcName or 'WinExec' in funcName or 'CreateProces' in funcName):
                            if bfea[1] == 1:
                                gbfea[0] = 1
                            Excute = True

                    for fq_api in high_freq_api:
                        if fq_api == funcName:
                            feature[tlens + 3 + m] = 1
                            break
                        m += 1

                    if gbfea[1] == 0:
                        for suspicious_symbol in IPfunc_imports:
                            if funcName.startswith(suspicious_symbol):
                                if bfea[0] == 0:
                                    gbfea[1] = 1
                                break
                    if gbfea[2] == 0 and bfea[0] == 1:
                        if b"WriteFile" in funcName:
                            gbfea[2] = 1
                    for suspicious_symbol in suspicious_imports:
                        if funcName.startswith(suspicious_symbol):
                            suspicious_imports_count += 1
                            break

    feature[-3] =  api_len  #201 alert api Count

    if Excute:                  #202 EXCUC
        feature[-2] = 1

    if suspicious_imports_count == len(suspicious_imports) and api_len < 20:
        feature[-1] = 1  # 203 import function

    feature.extend(gbfea)  #204 ~ 206 API behavior


    #导出表
    feature.append(0)                                      #207 export function
    if (hasattr(pfiles, 'DIRECTORY_ENTRY_EXPORT')):
        if not pfiles.FILE_HEADER.IMAGE_FILE_DLL:
         # exportNameLEN
            feature[-1] = pfiles.DIRECTORY_ENTRY_EXPORT.struct.NumberOfFunctions  # ExportSize

    tlens = len(feature)
    if tlens != 227:
        a = 0

    # 导入section表
    if (pfiles.sections[0].Name != b'.text' or pfiles.sections[0].Name != b'CODE'):   #208the first section is code section
         feature.append(1)
    else:
        feature.append(0)

    if (pfiles.sections[0].Characteristics & 0x20000000) == 0:      #209 the first section is writeable
        feature.append(1)
    else:
        feature.append(0)

    tlens = len(feature)
    if tlens != 229:
        a = 0
     #段长度大于文件总大小？？？？
    gbret2 = True
    datasect = [b'idata',b'rdata','data']
    sect_verctor = [0 for i in range(8)]

    for psection in pfiles.sections:
        if(psection.Characteristics & 0x20000000) > 0 and  (psection.Characteristics & 0x80000000) > 0 :
            if psection.Name == b'PAGE' and pfiles.is_driver():
                # Drivers can have a PAGE section with those flags set without
                # implying that it is malicious
                pass
            else:
                sect_verctor[0] += 1

        if(psection.Name == b'.text' and (psection.Characteristics & 0x20000000) == 0) or \
                (psection.Name != b'.text' and (psection.Characteristics & 0x20000000) > 0):#非常规代码段可执行
            sect_verctor[1] += 1

        #段名不可打印
        try:
            psection.Name.decode()
        except UnicodeDecodeError:
            sect_verctor[2] += 1

        #有可执行段
        if(psection.Characteristics & 0x20000000) > 0 and sect_verctor[3] != 0:
            sect_verctor[3] = 1


        #段的长度可疑
        if psection.Misc_VirtualSize > 0x10000000 and sect_verctor[4] == 0:
            sect_verctor[4] = 1
        #数据段可执行
        if sect_verctor[5] == 0 and psection.Name in datasect and psection.Characteristics & 0x20000000 > 0:
            sect_verctor[5]  = 1
        #代码段属性
        if gbret2 and (psection.Name == b'.text' or psection.Name == b'CODE'):
            for tmode in tchamode:
                feature.append(psection.Characteristics & tmode)
            feature.append(psection.Misc_VirtualSize - psection.SizeOfRawData)
            gbret2 = False
        #空段
        if(psection.SizeOfRawData == 0):
            sect_verctor[6] = 1
            sect_verctor[7] += 1


    if(gbret2):
        feature.extend([0 for i in range(len(tchamode) +1)])    #210 ～ 217.text段属性
    gtemp = is_probably_packed(pfiles)
    if gtemp[0]:
        feature.append(1)                                       #218可疑信息熵
    else:
        feature.append(0)
    feature.extend(gtemp[1:])                                   #219~220 信息熵

    feature.extend(sect_verctor)                                 #221 ～228 段属性

    if len(feature) != 249:
        a = 0
    return feature

def checkThenReturnLen(obj,elem):
    if hasattr(obj,elem):
        return len(obj[elem])
    else:
        return 0

def feature_ext(feat,thredA,thredB):
    maxn = max(thredA,thredB)
    minn  = min(thredA,thredB)
    interng = (maxn+minn)/2
    feat = [0 for i in range(4)]
    if feat < minn:
        feat[0] = 1
    elif feat >= maxn:
        feat[3] = 1
    elif feat >= minn and feat < interng:
        feat[1] = 1
    else:
        feat[2] = 1
    return feat

def feature_from_Peframe(filename,pe):
    feature = []
    pclass = pef_class(filename,pe)
    pinf = json.loads(pclass.get_pe_fileinfo())

    feature.append(pinf['file_size']) #1,filesize
    feature.append(len(pinf['pe_info']['apialert_info']))#2alert api count
    feature.append(len(pinf['pe_info']['antidbg_info'])) #3 debug infor
    feature.append(len(pinf['pe_info']['packer_info']))  #4
    feature.append(len(pinf['pe_info']['mutex_info']))   #5
    feature.append(len(pinf['pe_info']['antivm_info']))   #6

    if hasattr(pinf['pe_info']['meta_info'],'LegalCopyright'):   #7
        feature.append(1)
    else:
        feature.append(0)


    feature.append(checkThenReturnLen(pinf['file_found'], 'Object'))    #8 ～20
    feature.append(checkThenReturnLen(pinf['file_found'], 'Executable'))
    feature.append(checkThenReturnLen(pinf['file_found'], 'Autogen'))
    feature.append(checkThenReturnLen(pinf['file_found'], 'Binary'))
    feature.append(checkThenReturnLen(pinf['file_found'], 'Backup'))
    feature.append(checkThenReturnLen(pinf['file_found'], 'Compressed'))
    feature.append(checkThenReturnLen(pinf['file_found'], 'Log'))
    feature.append(checkThenReturnLen(pinf['file_found'], 'Database'))
    feature.append(checkThenReturnLen(pinf['file_found'], 'Temporary'))
    feature.append(checkThenReturnLen(pinf['file_found'], 'Registry'))
    feature.append(checkThenReturnLen(pinf['file_found'], 'Data'))

    feature.append(checkThenReturnLen(pinf['file_found'], 'Cabinet'))
    feature.append(checkThenReturnLen(pinf['file_found'], 'Web Page'))

    bfea = [0,0]
    if len(pinf['url_found']) != 0 or len(pinf['ip_found']) != 0:
        bfea[0] = 1
    if checkThenReturnLen(pinf['file_found'], 'Executable') != 0:
        bfea[1] = 1
    return  feature,bfea

def feature_gets(pfiles,filename):
    feature = feat_class(259)
    add_feat = []

    #feat,bfea = feature_from_Peframe(filename,pfiles)
    #feature.ext(feat)
    bfea = [0,0]

    #DOS Header0
    if(hasattr(pfiles,'DOS_HEADER')):                          #1 e_lfanew:224
        feature.app(pfiles.DOS_HEADER.e_lfanew)
    else:
        feature.app(0)
    #PE HEADER
    feature.app(pfiles.FILE_HEADER.NumberOfSections)        #2 numberofSections
    feature.app(pfiles.FILE_HEADER.NumberOfSymbols)         #3 numberofSymbols

    add_feat.extend(feature_ext(pfiles.FILE_HEADER.NumberOfSymbols,31362903.44,7612785.093)) #add 4 feat

    #OPTIONAL HEADERD
    if (hasattr(pfiles, 'OPTIONAL_HEADER')):
        if(pfiles.OPTIONAL_HEADER.CheckSum == 0):              #4 checkSum
            feature.app(1)
        else:
            feature.app(0)

        if (pfiles.OPTIONAL_HEADER.AddressOfEntryPoint > pfiles.sections[-1].VirtualAddress):  #5 entrypoint in the last section
            feature.app(1)
        else:
            feature.app(0)

        if (pfiles.OPTIONAL_HEADER.AddressOfEntryPoint > pfiles.sections[0].VirtualAddress and \
              pfiles.OPTIONAL_HEADER.AddressOfEntryPoint < (pfiles.sections[0].VirtualAddress +pfiles.sections[0].SizeOfRawData)):
            feature.app(1)
        else:
            feature.app(0)                                      #6 entrypoint in the first section

        if (pfiles.OPTIONAL_HEADER.AddressOfEntryPoint < pfiles.sections[0].VirtualAddress or \
              pfiles.OPTIONAL_HEADER.AddressOfEntryPoint > (pfiles.sections[-1].VirtualAddress +pfiles.sections[-1].SizeOfRawData)):
            feature.app(1)
        else:
            feature.app(0)                               #7 entrypoint out of section

        for mode in dllmode:
            if (mode & pfiles.OPTIONAL_HEADER.DllCharacteristics) > 0: #8 ~ 14 dll characteristics
                feature.app(1)
            else:
                feature.app(0)
        if pfiles.OPTIONAL_HEADER.DllCharacteristics == 0:
            add_feat[0] = 1

        tempV = pfiles.OPTIONAL_HEADER.SizeOfCode/pfiles.OPTIONAL_HEADER.SizeOfImage
        feature.app(tempV)                                                               #15 sizeofcode
        add_feat.extend(feature_ext(tempV,128.075,32.049))                                      #add 4 features

        feature.app(pfiles.OPTIONAL_HEADER.SizeOfHeapCommit)                            #16 sizeofheapcommit
        feature.app( pfiles.OPTIONAL_HEADER.SizeOfHeapReserve)                           #17 sizeofheapreserve

        feature.app( pfiles.OPTIONAL_HEADER.SizeOfStackCommit)                           #18 sizeofstackcommit
        feature.app(pfiles.OPTIONAL_HEADER.SizeOfStackReserve)                           #19 sizeofstackcommit

        feature.app(pfiles.OPTIONAL_HEADER.SizeOfInitializedData/pfiles.OPTIONAL_HEADER.SizeOfImage)  #20 SizeOfInitializedData
        add_feat.extend(feature_ext(pfiles.OPTIONAL_HEADER.SizeOfInitializedData/pfiles.OPTIONAL_HEADER.SizeOfImage, 8.294,34.858))#add 4 features

        feature.app(pfiles.OPTIONAL_HEADER.SizeOfUninitializedData/pfiles.OPTIONAL_HEADER.SizeOfImage)   #21 SizeOfUninitializedData
        add_feat.extend(feature_ext(pfiles.OPTIONAL_HEADER.SizeOfUninitializedData/pfiles.OPTIONAL_HEADER.SizeOfImage, 10.997,24.666))#add 4 features

        feature.app(pfiles.OPTIONAL_HEADER.MajorImageVersion)     #22 ~ 29 version information
        add_feat.extend(feature_ext(pfiles.OPTIONAL_HEADER.MajorImageVersion, 84.133,12.993))#add 4 features

        feature.app(pfiles.OPTIONAL_HEADER.MinorImageVersion)

        feature.app(pfiles.OPTIONAL_HEADER.MajorOperatingSystemVersion)
        feature.app(pfiles.OPTIONAL_HEADER.MinorOperatingSystemVersion)

        feature.app(pfiles.OPTIONAL_HEADER.MajorLinkerVersion)
        feature.app(pfiles.OPTIONAL_HEADER.MinorLinkerVersion)

        feature.app(pfiles.OPTIONAL_HEADER.MajorSubsystemVersion)
        feature.app(pfiles.OPTIONAL_HEADER.MinorSubsystemVersion)

        if pfiles.OPTIONAL_HEADER.ImageBase <= 0x400000:                             #30 imageBase
            feature.app(1)
        else:
            feature.app(0)

         #31 NumberOfRvaAndSizes
        feature.app(pfiles.OPTIONAL_HEADER.NumberOfRvaAndSizes)

        #data directory                                                                # 32 ~ 47
        m = 0
        feats = [0 for i in range(16)]
        bc =[0,0]
        for dataDirect in pfiles.OPTIONAL_HEADER.DATA_DIRECTORY:
            feats[m] = dataDirect.Size
            if m == 6:
                bc[0] = dataDirect.VirtualAddress
            elif m == 12:
                bc[1] = dataDirect.VirtualAddress

            m += 1
        feature.ext(feats)
        add_feat.extend(bc)

        feature.app( pfiles.OPTIONAL_HEADER.DATA_DIRECTORY[2].Size / pfiles.OPTIONAL_HEADER.SizeOfImage) #48 resource table size
        #feature.append(pfiles.OPTIONAL_HEADER.DATA_DIRECTORY[1].VirtualAddress) #IATRVA

    else:
        feature.ext([0 for i in range(45)])    #45 为OPTIONAL_HEADER的特征数
        add_feat.extend([0 for i in range(18)])  #add 4 features
    # resource detail

    feat = [0 for i in range(len(high_freq_resource))]    #49 ~51 key resource
    resid = []
    if (hasattr(pfiles, 'DIRECTORY_ENTRY_RESOURCE')):
        for rcsc in pfiles.DIRECTORY_ENTRY_RESOURCE.entries:
            temp_res_id = rcsc.id
            if (temp_res_id is None):
                temp_res_id = rcsc.struct.Id
            m = 0
            for gres_id in high_freq_resource:
                if(gres_id == temp_res_id):
                    feat[m] = 1
                    break
                m += 1
            resid.append(temp_res_id)
    feature.ext(feat)

    NumsOfSource_mark = [1,2,3,5,6,9,10,11,12,14,21,23,24]
    feat = [0 for i in range(len(NumsOfSource_mark))]               #52~64  the number of key resource
    m = 0
    for i in NumsOfSource_mark:  # 统计关键资源个数
        if i in resid:
            for rcsc in pfiles.DIRECTORY_ENTRY_RESOURCE.entries:
                temp_res_id = rcsc.id
                if (temp_res_id is None):
                    temp_res_id = rcsc.struct.Id
                if i == temp_res_id:
                    if (hasattr(rcsc, 'directory')):
                        feat[m]=len(rcsc.directory.entries)
                    else:
                        feat[m] = 0
                    break
        else:
            pass
        m += 1
    feature.ext(feat)

   # if feature.get_len() != 80:
    #    a= 0
    gbfea = [0,0,0]
    IPfunc_imports = ('WSASocket','socket','InternetConnect')
    # dll & api MODULE
    feat = [0 for i in range(len(high_freq_api) + 7)]             #65 ~ 68 key DLL
    api_len = 0
    Excute = False

    # 可疑行为
    suspicious_imports = set(['LoadLibrary', 'GetProcAddress'])  # 运行导入函数,增强特征的表现力
    suspicious_imports_2 = set(['WriteProcessMemory', 'CreateRemoteThread'])  # 代码注入
    suspicious_imports_count = 0
    suspicious_imports_count2 = 0

    if (hasattr(pfiles, 'DIRECTORY_ENTRY_IMPORT')):
        for importeddll in pfiles.DIRECTORY_ENTRY_IMPORT:
            if importeddll and (not isinstance(importeddll.dll, str)):
                dllname = importeddll.dll.decode()
            else:
                dllname = importeddll.dll
            if ('mscoree.dll' == dllname):
                feat[0] = 1
            elif ('wsock32.dll' == dllname):
                feat[1] = 1
            elif ('imm32.dll' == dllname):
                feat[2] = 1
            elif 'wininet.dll' == dllname:
                feat[3] = 1                                  #new add
            for importedapi in importeddll.imports:                #69 ~ 205 API
                api_len += 1
                if (importedapi.name is not None):
                    m = 0
                    if not isinstance(importedapi.name, str):
                        funcName = importedapi.name.decode()
                    else:
                        funcName = importedapi.name

                    if not Excute :
                        if ('ShellExecute' in funcName or 'WinExec' in funcName or 'CreateProces' in funcName):
                            if bfea[1] == 1:
                                gbfea[0] = 1
                            Excute = True

                    for fq_api in high_freq_api:
                        gclen = len(funcName) - len(fq_api)
                        if gclen < 0 or gclen >2:
                            m += 1
                            continue
                        if fq_api in funcName:
                            feat[4 + m] = 1
                            break
                        m += 1

                    if gbfea[1] == 0:
                        for suspicious_symbol in IPfunc_imports:
                            if funcName.startswith(suspicious_symbol):
                                if bfea[0] == 0:
                                    gbfea[1] = 1
                                break
                    if gbfea[2] == 0 and bfea[0] == 1:
                        if "WriteFile" in funcName:
                            gbfea[2] = 1
                    for suspicious_symbol in suspicious_imports:
                        if funcName.startswith(suspicious_symbol):
                            suspicious_imports_count += 1
                            break
                    for suspicious_f in suspicious_imports_2:
                        if funcName.startswith(suspicious_f):
                            suspicious_imports_count2 += 1
                            break

    feat[-3] =  api_len  #206 alert api Count

    if Excute:                  #207 EXCUC
        feat[-2] = 1

    if suspicious_imports_count == len(suspicious_imports) and api_len < 20:
        feat[-1] = 1  # 208 import function

    feature.ext(feat)
    feature.ext(gbfea)  #209 ~ 211 API behavior

    if suspicious_imports_count2 == len(suspicious_imports_2):  # 代码注入
        add_feat.append(1)
    else:
        add_feat.append(0)

    #导出表
    gtemp = 0                                     #212 export function
    if (hasattr(pfiles, 'DIRECTORY_ENTRY_EXPORT')):
        if not pfiles.FILE_HEADER.IMAGE_FILE_DLL:
         # exportNameLEN
            gtemp = pfiles.DIRECTORY_ENTRY_EXPORT.struct.NumberOfFunctions  # ExportSize
    feature.app(gtemp)

    #if feature.get_len() != 227:
     #   a = 0
    # 导入section表
    sname0 = psectname_trans(pfiles.sections[0].Name)
    if (sname0 != '.text' or sname0 != 'CODE'):   #213the first section is code section
         feature.app(1)
    else:
        feature.app(0)

    if (pfiles.sections[0].Characteristics & 0x20000000) == 0:      #214 the first section is writeable
        feature.app(1)
    else:
        feature.app(0)

     #段长度大于文件总大小？？？？
    gbret2 = True
    datasect = ['.idata','.rdata','.data']
    sect_verctor = [0 for i in range(8)]

    add_feat.extend([0,0])
    for psection in pfiles.sections:

        psect_name = psectname_trans(psection.Name)

        if(psection.Characteristics & 0x20000000) > 0 and  (psection.Characteristics & 0x80000000) > 0 :
            if  psect_name == 'PAGE' and pfiles.is_driver():
                # Drivers can have a PAGE section with those flags set without
                # implying that it is malicious
                pass
            else:
                sect_verctor[0] += 1

        if( psect_name== '.text' and (psection.Characteristics & 0x20000000) == 0) or \
                ( psect_name != '.text' and (psection.Characteristics & 0x20000000) > 0):#非常规代码段可执行
            sect_verctor[1] += 1

        #段名不可打印
        try:
            psection.Name.decode()
        except UnicodeDecodeError:
            sect_verctor[2] += 1

        #可执行段个数
        if(psection.Characteristics & 0x20000000) > 0:
            sect_verctor[3] += 1


        #段的长度可疑
        if psection.Misc_VirtualSize > 0x10000000 and sect_verctor[4] == 0:
            sect_verctor[4] = 1
        #数据段可执行
        if sect_verctor[5] == 0 and (psect_name in datasect) and psection.Characteristics & 0x20000000 > 0:
            sect_verctor[5]  = 1
        #代码段属性
        if gbret2 and ( psect_name == '.text' or psect_name == 'CODE'):
            for tmode in tchamode:
                if (psection.Characteristics & tmode) > 0:
                    feature.app(1)
                else:
                    feature.app(0)
            feature.app(abs(psection.Misc_VirtualSize - psection.SizeOfRawData))
            gbret2 = False
        #空段
        if(psection.SizeOfRawData == 0):
            sect_verctor[6] = 1
            sect_verctor[7] += 1

        if psect_name == '.data':
            add_feat[-2] = psection.SizeOfRawData
        if psect_name == '.text':
            add_feat[-1] = psection.SizeOfRawData
    if(gbret2):
        feature.ext([0 for i in range(len(tchamode) +1)])    #215 ～ 223.text段属性
    gtemp = is_probably_packed(pfiles)
    if gtemp[0]:
        feature.app(1)                                       #224可疑信息熵
    else:
        feature.app(0)
    feature.app(gtemp[1])#225~226信息熵
    feature.app(gtemp[2])
    feature.ext(sect_verctor)                                 #227 ～234 段属性

    if feature.get_len() != 234:
        print filename
        exit()
    feature.ext(add_feat)

    ibb = 0
    for itm in feature.get_feat():
        ibb += 1
        if itm < 0:
            print(ibb,'err negtive')
            a= input()
    if feature.get_len() != 259:
        a = 0
    return feature.get_feat()

def main():
    import pefile
    filename =''
    feature_gets(pefile.PE(filename),filename)

if __name__ == '__main__':
    main()





