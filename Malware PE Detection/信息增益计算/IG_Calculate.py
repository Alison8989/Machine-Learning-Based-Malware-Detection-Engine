# -*- coding: utf-8 -*-

'''
    计算特征的信息增益(未测试)
'''

import math
import numpy as np

def entroyc(py):
    if py < 0:
        raise
    elif py == 0:
        return 0
    else:
        return -py*math.log2(py)

def entroyc_conditon(p_xy,p_y):
    '''
    :param p_xy: x，y同时出现的概率
    :param p_y: y出现的概率
    '''
    if p_xy < 0 or p_y < 0:
        raise
    elif p_y == 0 or p_xy == 0:
        return 0
    else:
        return  -p_xy * math.log2(p_xy / p_y)

def IG_calc(kind,pb):#二分类
    #pb的格式为[px0_y0,px0_y1,px0_y2,...,px1_y0,......]
    if kind == 0 or not isinstance(kind,int):
        return 0
    if 2*kind != len(pb):
        raise
    if sum(pb) != 1:
        raise
    pk = [pb[i] + pb[kind + i] for i in range(kind)]

    negtive_p = sum([pb[:kind]])   #特征不出现的概率
    positive_p= sum([pb[kind:]])   #特征出现的概率

    ak_entroy = 0
    for i in range(kind): #计算总的信息熵
        ak_entroy += entroyc(pk[i])
    ck_entroy = 0
    for i in range(2*kind): #计算总的条件熵
        if i < kind:
            ck_entroy += entroyc_conditon(pb[i],negtive_p)
        else:
            ck_entroy += entroyc_conditon(pb[i],positive_p)
    return ak_entroy - ck_entroy

def count(condition,param,featureset,sample_class,kind):
    '''
    :param param: 参数字典，指示第Index个特征，及其他condition相关参数
    :param condition: 当特征满足条件时，则该特征为正，否则为负,函数参数
    :param featureset: 特征集
    :param sample_class:特征对应的类别
    '''
    if not hasattr(param,'index'):
        raise
    pcount = [0 for i in range(len(kind))]
    ncount = [0 for i in range(len(kind))]
    ic = 0
    total_samples = 0
    for itm in featureset:
        if sample_class[ic] not in kind: #不再统计的类别中
            ic += 1
            continue
        gc = 0
        for sk in kind:
            if sk == sample_class[ic]:
                break
            else:
                gc += 1
        param['value'] = itm[param['index']]
        del param['index']
        if condition(** param):
            pcount[gc] += 1
        else:
            ncount[gc] += 1
        ic += 1
        total_samples += 1
    prate = [ab/total_samples for ab in ncount]
    prate.extend([ab/total_samples for ab in pcount])
    return prate

def condition_func(value,ref = 0.5):  #根据需要，可设立别的条件
    if isinstance(value,int) or isinstance(value,float):
        if value > ref:
            return True
    return False

def condition_func_str(value,ref,method = 'all'):
    if isinstance(value,str) and isinstance(ref,str):
        if method == 'all':
            if value == ref:
                return True
            else:
                return  False
        else:
            if value in ref:
                return True
            else:
                return False
    return  False

def get_feature_IG(featureset,sample_class):
    slen = len(sample_class)
    if len(featureset) != slen:
        raise
    kind = np.unique(sample_class) #可自定义类别
    IG = []
    need_to_processing = [1,3,4]#需要计算信息增益的特征在特征集的位置
    for i in need_to_processing:
        param = {}
        param['index'] = i
        #数字
        param['ref'] = 0.5
        prate = count(condition_func, param, featureset, sample_class, kind)
        #字符
        #param['ref'] = 'ref string'
        #param['method'] = 'all'
        #prate = count(condition_func_str,param, featureset, sample_class, kind)
        IG.append(IG_calc(len(kind),prate))
        del param
    return sorted(IG,reverse=True)  #返回各个特征信息增益





